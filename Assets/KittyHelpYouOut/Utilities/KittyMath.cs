using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
#if false
using Unity.Mathematics;
#endif
using UnityEngine;
using Random = System.Random;

namespace KittyHelpYouOut
{
    public struct KittyMath
    {
        public static Quaternion Damp(Quaternion a, Quaternion b, float lambda, float dt)
        {
            return Quaternion.Slerp(a, b, 1 - Mathf.Exp(-lambda * dt));
        }
        public static  Quaternion Damp(Vector3 a,Vector3 b,float lambda,float dt)
        {
            Quaternion x = Quaternion.Euler(a.x, a.y, a.z);
            Quaternion y = Quaternion.Euler(b.x, b.y, b.z);
            return Quaternion.Slerp(x, y, 1 - Mathf.Exp(-lambda * dt));
        }
        /// <summary>
        /// 返回参数的符号，0则返回0
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public static float SignWithZero(float i)
        {
            if (i>0)
            {
                return 1;
            }else if (i<0)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
        public static Vector3 V3Mean(Vector3[] vs)
        {
            Vector3 mv = Vector3.zero;
            foreach (Vector3 v in vs)
            {
                mv += v;
            }
            return mv / (float)vs.Length;
        }

        public static Vector3 V3Mean(List<Vector3> vs)
        {
            Vector3 mv = Vector3.zero;
            foreach (Vector3 v in vs)
            {
                mv += v;
            }
            return mv / (float)vs.Count;
        }

        public static Vector3 V3Mean(Vector3 v1, Vector3 v2)
        {

            return v1 + v2 / 2f;
        }

        public static float Kmh2Ms(float kmh)
        {
            return kmh * 1000f / 3600f;
        }
        public static float Ms2Kmh(float ms)
        {
            return ms * 3600f / 1000f;
        }
        public static Vector3 OutputInspectorEuler(Transform trans, bool isGlobal = true)
        {
            Vector3 angle;
            if (isGlobal)
            {
                angle = trans.eulerAngles;
            }
            else
            {
                angle = trans.localEulerAngles;
            }
            float x = angle.x;
            float y = angle.y;
            float z = angle.z;

            if (Vector3.Dot(trans.up, Vector3.up) >= 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = angle.x - 360f;
                }
            }
            if (Vector3.Dot(trans.up, Vector3.up) < 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = 180 - angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = 180 - angle.x;
                }
            }

            if (angle.y > 180)
            {
                y = angle.y - 360f;
            }

            if (angle.z > 180)
            {
                z = angle.z - 360f;
            }

            return new Vector3(x, y, z);
        }
        
        public static Vector3 OutputInspectorEuler(Quaternion rotation,Vector3 up)
        {
            Vector3 angle=rotation.eulerAngles;
            float x = angle.x;
            float y = angle.y;
            float z = angle.z;

            if (Vector3.Dot(up, Vector3.up) >= 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = angle.x - 360f;
                }
            }
            if (Vector3.Dot(up, Vector3.up) < 0f)
            {
                if (angle.x >= 0f && angle.x <= 90f)
                {
                    x = 180 - angle.x;
                }
                if (angle.x >= 270f && angle.x <= 360f)
                {
                    x = 180 - angle.x;
                }
            }

            if (angle.y > 180)
            {
                y = angle.y - 360f;
            }

            if (angle.z > 180)
            {
                z = angle.z - 360f;
            }

            return new Vector3(x, y, z);
        }
        
        public static float CalculatePitchG(Transform transform, Vector3 localVelocity, float pitchRateDeg)
        {
            // Angular velocity is in radians per second.
            var pitchRate = pitchRateDeg * Mathf.Deg2Rad;

            // If there is no angular velocity in the pitch, then there's no force generated by a turn.
            // Return only the planet's gravity as it would be felt in the vertical.
            if (Mathf.Abs(pitchRate) < Mathf.Epsilon)
                return transform.up.y;

            // Local pitch velocity (X) is positive when pitching down.

            // Radius of turn = velocity / angular velocity
            float radius = localVelocity.z / pitchRate;

            // The radius of the turn will be negative when in a pitching down turn.

            // Force is mass * radius * angular velocity^2
            float verticalForce = (localVelocity.z * localVelocity.z) / radius;

            // Express in G
            float verticalG = -verticalForce / 9.8f;

            // Add the planet's gravity in. When the up is facing directly up, then the full
            // force of gravity will be felt in the vertical.
            verticalG += transform.up.y;

            return verticalG;
        }
        
        public static void KDShuffle<T>(ref T[] array)
        {
            Random r = new Random();
            for (int i = array.Length - 1; i > 0; i--)
            {
                int randomIndex = r.Next(0, i + 1);
                (array[randomIndex], array[i]) = (array[i], array[randomIndex]);
            }
        }
#if false

        public static float3 ClipOnPlane(float3 source, float3 normal)
        {
            float3 result = source;
            var dot = math.dot(source, normal);
            if (dot<0)
            {
                //if dot product smaller than 0, clip
                result = source - math.projectsafe(source, normal);
            }
            return result;
        }

        public static bool VectorPlaneIntersection(float3 planeNormal, float3 planePoint, float3 vectorStart,float3 vectorEnd, out float3 intersection)
        {
            float planeD = -math.dot(planeNormal, planePoint);
            float t=-(math.dot(planeNormal,vectorStart)+planeD)/math.dot(planeNormal,vectorEnd-vectorStart);
            if (t >= 0 && t < 1)
            {
                intersection = vectorStart + t * (vectorEnd - vectorStart);
                return true;
            }
            else
            {
                intersection=float3.zero;
                return false;
            }
        }
#endif
        public static List<Vector2> GetConvexHull(List<Vector2> points)
        {
            //If we have just 3 points, then they are the convex hull, so return those
            if (points.Count == 3)
            {
                //These might not be ccw, and they may also be colinear
                return points;
            }

            //If fewer points, then we cant create a convex hull
            if (points.Count < 3)
            {
                return null;
            }



            //The list with points on the convex hull
            List<Vector2> convexHull = new List<Vector2>();

            //Step 1. Find the vertex with the smallest x coordinate
            //If several have the same x coordinate, find the one with the smallest z
            Vector2 startVertex = points[0];

            Vector2 startPos = startVertex;

            for (int i = 1; i < points.Count; i++)
            {
                Vector2 testPos = points[i];

                //Because of precision issues, we use Mathf.Approximately to test if the x positions are the same
                if (testPos.y < startPos.y || (Mathf.Approximately(testPos.y, startPos.y) && testPos.x < startPos.x))
                {
                    startVertex = points[i];

                    startPos = startVertex;
                }
            }

            //This vertex is always on the convex hull
            convexHull.Add(startVertex);

            points.Remove(startVertex);

          

            //Step 2. Loop to generate the convex hull
            Vector2 currentPoint = convexHull[0];

            //Store colinear points here - better to create this list once than each loop
            List<Vector2> colinearPoints = new List<Vector2>();

            int counter = 0;

            while (true)
            {
                //After 2 iterations we have to add the start position again so we can terminate the algorithm
                //Cant use convexhull.count because of colinear points, so we need a counter
                if (counter == 2)
                {            
                    points.Add(convexHull[0]);
                }
            
                //Pick next point randomly
                Vector2 nextPoint = points[UnityEngine.Random.Range(0, points.Count)];


                //Test if there's a point to the right of ab, if so then it's the new b
                for (int i = 0; i < points.Count; i++)
                {
                    //Dont test the point we picked randomly
                    if (points[i].Equals(nextPoint))
                    {
                        continue;
                    }
                
                    Vector2 iPoint = points[i];

                    //Where is c in relation to a-b
                    // > 0 -> to the right
                    // = 0 -> on the line
                    // < 0 -> to the left
                    float relation = LeftRightRelation(currentPoint, nextPoint, iPoint);
                    
                    //Colinear points
                    //Cant use exactly 0 because of floating point precision issues
                    //This accuracy is smallest possible, if smaller points will be missed if we are testing with a plane
                    float accuracy = 0.1f;

                    if (relation < accuracy && relation > -accuracy)
                    {
                        colinearPoints.Add(points[i]);
                    }
                    //To the left = better point, so pick it as next point on the convex hull
                    else if (relation < 0f)
                    {
                        nextPoint = points[i];
                                            

                        //Clear colinear points
                        colinearPoints.Clear();
                    }
                    //To the left = worse point so do nothing
                }

            

                //If we have colinear points
                if (colinearPoints.Count > 0)
                {
                    colinearPoints.Add(nextPoint);

                    //Sort this list, so we can add the colinear points in correct order
                    colinearPoints = colinearPoints.OrderBy(n => Vector2.SqrMagnitude(n - currentPoint)).ToList();

                    convexHull.AddRange(colinearPoints);

                    currentPoint = colinearPoints[colinearPoints.Count - 1];

                    //Remove the points that are now on the convex hull
                    for (int i = 0; i < colinearPoints.Count; i++)
                    {
                        points.Remove(colinearPoints[i]);
                    }

                    colinearPoints.Clear();
                }
                else
                {
                    convexHull.Add(nextPoint);
                
                    points.Remove(nextPoint);

                    currentPoint = nextPoint;
                }

                //Have we found the first point on the hull? If so we have completed the hull
                if (currentPoint.Equals(convexHull[0]))
                {
                    //Then remove it because it is the same as the first point, and we want a convex hull with no duplicates
                    convexHull.RemoveAt(convexHull.Count - 1);

                    break;
                }

                counter += 1;
            }

            return convexHull;
        }
        

        private static float LeftRightRelation(Vector2 a, Vector2 b, Vector2 c)
        {
            return V2Cross(b - a, c - b);
        }
        public static float V2Cross(Vector2 a, Vector2 b)
        {
            var result = a.x * b.y - a.y * b.x;
            return result;
        }

        public static Vector3[] GetFanPoints(Vector3 start,Vector3 forward,float maxRange,float minRange,float angle, int farArcPointCount,int nearArcPointCount)
        {
            if (minRange<0)
            {
                Debug.LogWarning($"range must be positive");
                minRange = 0;
            }
            if (maxRange < minRange)
            {
                Debug.LogWarning($"Max range cannot shorter than min range");
                maxRange = minRange;
            }
            // var nearArcPointCount = (int)(farArcPointCount * (minRange / maxRange));
            var points = new Vector3[farArcPointCount+nearArcPointCount];
            var leftArc = Quaternion.AngleAxis(angle / -2f, Vector3.up) * forward;
            var rightArc = Quaternion.AngleAxis(angle / 2f, Vector3.up) * forward;
            //set far arc points
            for (int i = 0; i < farArcPointCount; i++)
            {
                var localArc = Quaternion.AngleAxis(angle / (farArcPointCount-1) * i, Vector3.up) * leftArc;
                points[i] = start + localArc * maxRange;
            }
            for (int i = 0; i+farArcPointCount < points.Length; i++)
            {
                var localArc = Quaternion.AngleAxis(-angle / (nearArcPointCount-1) * i, Vector3.up) * rightArc;
                points[i + farArcPointCount] = start + localArc * minRange;
            }
            return points;
        }
        
    }
}
